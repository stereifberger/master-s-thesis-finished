from imports import *

num_processes = cpu_count()
def pad_single(sublist = list, pad_length = int): # Pad a list to pad_length
    return sublist + [0] * (pad_length - len(sublist))


"""
Description: Implementation of multprocessing for my function "pad_single"
Generated by: GPT-4
URL of Service: https://platform.openai.com/playground
"""
def pad_single_PA(sublist, max_length): # Pad list using all avaiable CPU threads
    pad_partial_wrapper = partial(pad_single, max_length) # Definition of partial function on basis of my existing padding function
    with Pool(processes = num_processes) as pool: # Assignment of the partial function to avaiable CPU threads
        padded = list(tqdm(pool.imap(pad_partial_wrapper, sublist), total=len(sublist)))
        return padded

"""Pad sublists of lists to same length. Necessary because in the task the
output is longer than the input which is not possible in some architectures."""
def pad(inpt = list):
    for sublist in tqdm(inpt, desc="Padded exmaples from X"):
        while len(sublist) < len(max(inpt, key = len)):
            sublist.append(0)
    return inpt

"""
Title: Python program to get all subsets of given size of a set
Last updated: 2021-08-09
URL: https://www.geeksforgeeks.org/python-program-to-get-all-subsets-of-given-size-of-a-set/
"""
# The second function uses the first to partition lists into subsets of length n.
def subsets(numbers):
    if numbers == []:
        return [[]]
    x = subsets(numbers[1:])
    return x + [[numbers[0]] + y for y in x]

def subsets_with_length(numbers, n):
    return [x for x in subsets(numbers) if len(x)==n]

"""Numbers in list encoded as str or int are listed as single digit ints."""
def to_int(data = list):
  new_data = [0]
  for i in data:
    for t in str(i):
      new_data.append(int(t))
    new_data.append(0)
  return new_data

"""
Description: A function that converts all sublists' brackets in a list to numbers with a dictionary
Generated by: GPT-4
Date: 2024-
URL of Service: https://platform.openai.com/playground
"""
def lflt(inpt = list, insd=False):
    flat = []
    if insd:
        flat.append(calculi.symb["LB"])
    
    for item in inpt:
        if isinstance(item, list):
            flat.extend(lflt(item, True))
        else:
            flat.append(item)
    if insd:
        flat.append(calculi.symb["RB"])
    
    return flat

def reve(inpt): 
    x_train_3d = inpt.view(len(inpt), int(len(inpt[0])/(t_nu+8)), t_nu+8) # Reshape inpt to three dimensional list again
    inpt_reversed = []
    for i in x_train_3d: # Take each derivation encoded as sublist iterativly
        reverse_x_train = torch.argmax(i, dim=1) # Reverse the onehot encoding back to integers
        brackets = [t_nu + 2, t_nu +3] # Define integers that represent brackets
        reverse_x_train = reverse_x_train.tolist()
        reverse_x_train = ["[" if item == (t_nu + 2) else item for item in reverse_x_train] # Replace integers with brckets
        reverse_x_train = ["]" if item == (t_nu + 3) else item for item in reverse_x_train]
        reverse_x_train = [str(item) for item in reverse_x_train] # Convert integers to strings
        stri = ", ".join(str(item) for item in reverse_x_train) # á¸¾ake a list out of the strings
        stri = "[" + stri + "]" # Encapsulate that list of strings in brackets.
        stri = stri.replace("[,", "[").replace(", ]", "]") # Delete commas
        reverse_x_train = eval(stri) # Make a list again, where strings encapsulated in brackets are taken as sublists
        inpt_reversed.append(stri)
    return inpt_reversed


def reve(inpt):
    inpt_reversed = []
    for i in inpt:
        reverse_x_train = torch.argmax(i, dim=1)
        reverse_x_train = reverse_x_train.tolist()
        reverse_x_train = ["[" if item == (t_nu + 2) else item for item in reverse_x_train]
        reverse_x_train = ["]" if item == (t_nu + 3) else item for item in reverse_x_train]
        reverse_x_train = [str(item) for item in reverse_x_train]
        stri = ", ".join(str(item) for item in reverse_x_train)
        stri = "[" + stri + "]"
        stri = stri.replace("[,", "[").replace(", ]", "]")
        inpt_reversed.append(stri)
    return inpt_reversed

def reve_y(inpt): # Revert the conversion of brackets with the dictionary from the function lflt for the output data.
    inpt_reversed = []
    for i in inpt:
        _, indices = torch.max(i, dim=1)
        reverse_x_train = F.one_hot(indices, num_classes=i.shape[1]) 
        reverse_x_train = torch.argmax(i, dim=1)
        reverse_x_train = reverse_x_train.tolist()
        reverse_x_train = ["[" if item == (t_nu + 2) else item for item in reverse_x_train]
        reverse_x_train = ["]" if item == (t_nu + 3) else item for item in reverse_x_train]
        reverse_x_train = [str(item) for item in reverse_x_train]
        stri = ", ".join(str(item) for item in reverse_x_train)
        stri = "[" + stri + "]"
        inpt_reversed.append(stri)
    return inpt_reversed

# Convert a single derivation with lflt to no longer have sublists and then to to onehot encoding
def convert_single(single_outp, max_y_train_len):
    single_outp = lflt(single_outp)
    padding_length = max_y_train_len
    while len(single_outp) < padding_length:
        single_outp.append(0)
    single_outp = torch.tensor(single_outp)
    single_outp = F.one_hot(single_outp, num_classes=t_nu+9)
    single_outp = np.array(single_outp)
    single_outp = torch.tensor(single_outp, dtype= torch.float32)
    single_outp = torch.flatten(single_outp)
    return single_outp